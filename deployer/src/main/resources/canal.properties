#################################################
######### 		common argument		############# 
#################################################
canal.id= 1
canal.ip=
canal.port= 11111
canal.zkServers=
# flush data to zk
canal.zookeeper.flush.period = 1000
# flush meta cursor/parse position to file
canal.file.data.dir = ${canal.conf.dir}
canal.file.flush.period = 1000

# 表示RingBuffer队列的最大容量，也就是可缓存的binlog事件的最大记录数
# 其值需要为2的指数(原因如前所述，canal通过位运算进行取余)，默认值为2^16=16384。
canal.instance.memory.buffer.size = 16384

# 表示RingBuffer使用的内存单元, 默认是1kb。
# 和canal.instance.memory.buffer.size组合决定最终的内存使用大小。
# 需要注意的是，这个配置项仅仅是用于计算占用总内存，并不是限制每个event最大为1kb。
canal.instance.memory.buffer.memunit = 1024 

## 表示canal内存store中数据缓存模式，支持两种方式：
## 1) ITEMSIZE :
#   根据buffer.size进行限制，只限制记录的数量。
#   这种方式有一些潜在的问题，举个极端例子，假设每个event有1M，那么16384个这种event占用内存要达到16G左右，基本上肯定会造成内存溢出(超大内存的物理机除外)。
#  2) MEMSIZE:
#  根据buffer.size  * buffer.memunit的大小，限制缓存记录占用的总内存大小。
#  指定为这种模式时，意味着默认缓存的event占用的总内存不能超过16384*1024=16M。这个值偏小，但笔者认为也足够了。
#  因为通常我们在一个服务器上会部署多个instance，每个instance的store模块都会占用16M，因此只要instance的数量合适，也就不会浪费内存了。
#  部分读者可能会担心，这是否限制了一个event的最大大小为16M，实际上是没有这个限制的。
#  因为canal在Put一个新的event时，只会判断队列中已有的event占用的内存是否超过16M，
#  如果没有，新的event不论大小是多少，总是可以放入的(canal的内存计算实际上是不精确的)，
#  之后的event再要放入时，如果这个超过16M的event没有被消费，则需要进行等待。
canal.instance.memory.batch.mode = MEMSIZE

## detecing config
canal.instance.detecting.enable = false
#canal.instance.detecting.sql = insert into retl.xdual values(1,now()) on duplicate key update x=now()
canal.instance.detecting.sql = select 1
canal.instance.detecting.interval.time = 3
canal.instance.detecting.retry.threshold = 3
canal.instance.detecting.heartbeatHaEnable = false

# support maximum transaction size, more than the size of the transaction will be cut into multiple transactions delivery
canal.instance.transaction.size =  1024
# mysql fallback connected to new master should fallback times
canal.instance.fallbackIntervalInSeconds = 60

# network config
canal.instance.network.receiveBufferSize = 16384
canal.instance.network.sendBufferSize = 16384
canal.instance.network.soTimeout = 30

# binlog filter config
canal.instance.filter.query.dcl = false
canal.instance.filter.query.dml = false
canal.instance.filter.query.ddl = false
canal.instance.filter.table.error = false

# binlog format/image check
canal.instance.binlog.format = ROW,STATEMENT,MIXED 
canal.instance.binlog.image = FULL,MINIMAL,NOBLOB

# binlog ddl isolation
# 其对于Get操作生效，用于设置ddl语句是否单独一个batch返回(比如下游dml/ddl如果做batch内无序并发处理,会导致结构不一致)。
# 其值通过canal.instance.get.ddl.isolation配置项来设置，默认值为false。
canal.instance.get.ddl.isolation = false

#################################################
######### 		destinations		############# 
#################################################
canal.destinations= example
# conf root dir
canal.conf.dir = ../conf
# auto scan instance dir add/remove and start/stop instance
canal.auto.scan = true
canal.auto.scan.interval = 5

canal.instance.global.mode = spring 
canal.instance.global.lazy = false
#canal.instance.global.manager.address = 127.0.0.1:1099
#canal.instance.global.spring.xml = classpath:spring/memory-instance.xml
#canal.instance.global.spring.xml = classpath:spring/file-instance.xml
canal.instance.global.spring.xml = classpath:spring/default-instance.xml